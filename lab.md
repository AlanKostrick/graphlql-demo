# Practice: Apply the ability to add a course to the application 
In this lab, you can use what is already in place as a pattern to create a `mutataion` to `addCourse` to the application. 

If you happen to get stuck on this lab, [here is the solution](https://github.com/AlanKostrick/graphlql-demo/tree/lab-solution)

<br>
<br>
<br>

## Step 1: Add to the build schema

Open the file `server/server.js` 
<br>

1. In this file, let's first focus on the `buildSchema` at the top
2. Add a new `mutation` in the `type Mutation` for `addCourse` ... think about the information you will need for a couse. 
    - To add a course in the application, this will probably have to be done by a user in some type of form. So they will need to be able to specify all of the data except the `id`
    - The `id` should be autogenerated... lets head to the `client` terminal and `npm install uuid` so that our server can autogenerate these for us, taking the responsibility off of the user 

Your new mutation will look something like this 

```javascript
addCourse(title: String, authors: [AuthorInput], description: String, topic: String, url: String): Course
```

And now our updated `type Mutation` will have 2 different functions inside of it
```javascript
 type Mutation {
        updateCourseTopic(id: String!, topic: String!): Course
        addCourse(title: String, authors: [AuthorInput], description: String, topic: String, url: String): Course
    },
```

3. What is going on with `authors` ? 
We have made `authors` take in an `Author` object. This is pretty common right... bringing in basic fields like `String`, `Int` and specific objects that we declare along the way. 

But this cannot just be brought in as an object, GraphQL will error out, asking for an `input` object instead of a `type`. Let's create that now. 

```javascript
 input AuthorInput {
        firstName: String, 
        lastName: String
    }
```

### Verify your new `buildSchema` 

Your new `schema` object should look like the following

```javascript
// GraphQL schema
var schema = buildSchema(`
    input AuthorInput {
        firstName: String, 
        lastName: String
    }
    type Query {
        course(id: String!): Course
        coursesByTopic(topic: String): [Course]
        allCourses: [Course]
    },
    type Mutation {
        updateCourseTopic(id: String!, topic: String!): Course
        addCourse(title: String, authors: [AuthorInput], description: String, topic: String, url: String): Course
    },
    type Author {
        firstName: String 
        lastName: String
    }
    type Course {
        id: String
        title: String
        authors: [Author]
        description: String
        topic: String
        url: String
    }
`);
```

<br>
<br>
<br>

## Step 2: Create the `addCourse` function 

Continuing in the file `server/server.js` 

In this step we need to find a way to pass all of the custom fields that we can imagine coming from the form that the user fills out, along with a unique autogenerated id. We also need to ensure, with some light validation, that we do not place duplicate courses into the application. There are a lot of stronger ways to do this, but for our demo sake, we are simply not going to be allowed a course with the same title to be added to the application. 

1st lets import the `generateId` function that we will leverage for this new function.
```javascript
const { v4: generateId } = require('uuid');
```

Now go ahead and create the function.

```javascript
var addCourse = function ({ title, authors, description, topic, url }) {

    let foundCourse = null;

    foundCourse = coursesData.find(course => course.title === title);

    if (!foundCourse) {
        var course = {
            id: generateId(),
            title: title,
            authors: authors,
            description: description,
            topic: topic,
            url: url
        }
        coursesData.push(course);
        return course;
    } else {
        return foundCourse;
    }
}
```

Finally, update the `root` to include this new function 

```javascript
var root = {
    course: getCourse,
    coursesByTopic: getCoursesByTopic,
    allCourses: getAllCourses,
    updateCourseTopic: updateCourseTopic,
    addCourse: addCourse
};
```


Do not forget to re start the server once these changes are in place.

<br>
<br>
<br>

## Step 3: Test the new mutation out in the graphql playground before moving into the React application. Here is an example mutation that you can execute

```javascript
mutation AddCourse($title:String, $authors:[AuthorInput], $description:String, $topic:String, $url:String){
  addCourse(title:$title, authors:$authors, description:$description, topic:$topic, url:$url){
    title
    authors{
			firstName
      lastName
    }
    description
    topic
    url
    id
  }
}
```

And in the `Query Variables` section at the bottom of the playground... go ahead and add the details
```javascript
{
  "title": "Isn't GraphQL fun",
  "authors": [
    {
      "firstName": "Alan",
      "lastName": "Kostrick"
    }
  ],
  "description": "An introduction to GraphQLin node and React",
  "topic": "GraphQL",
  "url": "codelaborators.io"
}
```


<br>
<br>
<br>

## Step 4: Update the React client 

Let's work in the `client/screens/CoursesScreen.js` file. 

**Important Note** We are going to be working in this file for simplicity sake, but when its all complete, there are several components that can be extracted into their own files

1. Add the mutation from the playground to the file

```javascript
const ADD_COURSE = gql`
    mutation AddCourse($title:String, $authors:[AuthorInput], $description:String, $topic:String, $url:String){
        addCourse(title:$title, authors:$authors, description:$description, topic:$topic, url:$url){
        title
        authors{
            firstName
            lastName
        }
        description
        topic
        url
        id
        }
    }
`
```

2. Add some state variables to trigger the new modal, as well as to handle the fields for the new course
Since our form will be a Controlled Form, inside of a modal, we need some variables

```jsx
const [showAddModal, setShowAddModal] = useState(false);
const [newCourseTitle, setNewCourseTitle] = useState(null);
const [newCourseAuthorFirstName, setNewCourseAuthorFirstName] = useState(null);
const [newCourseAuthorLastName, setNewCourseAuthorLastName] = useState(null);
const [newCourseDescription, setNewCourseDescription] = useState(null);
const [newCourseTopic, setNewCourseTopic] = useState(null);
const [newCourseUrl, setNewCourseUrl] = useState(null);
```

That's quite a few variables. Once again, this is another thing that can be refactored to either be managed by a `useForm` hook or in a state management library like `redux` but for now, declaring these variables will work in the scope of our activity. 

3. Add the JSX to the UI

We need a `Button` to add a course and a `Modal` to manage the form data.

```jsx
<Button onClick={() => setShowAddModal(true)}>Add a course</Button>
            <Modal show={showAddModal} onHide={() => setShowAddModal(false)}>
                <Modal.Header closeButton>
                    <Modal.Title>Add a course</Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <>
                        <Form>
                            <Form.Group as={Row} className="mb-3" controlId="formPlaintextTitle">
                                <Form.Label column sm="2">
                                    Title
                                </Form.Label>
                                <Col sm="10">
                                    <Form.Control type="text" placeholder='Enter a title' onChange={(e) => setNewCourseTitle(e.target.value)} />
                                </Col>
                            </Form.Group>
                            <Form.Group as={Row} className="mb-3" controlId="formPlaintextFirstName">
                                <Form.Label column sm="2">
                                    Author
                                </Form.Label>
                                <Col sm="10">
                                    <Form.Control type="text" placeholder='Enter author first name' onChange={(e) => setNewCourseAuthorFirstName(e.target.value)} />
                                </Col>
                            </Form.Group>
                            <Form.Group as={Row} className="mb-3" controlId="formPlaintextLastName">
                                <Form.Label column sm="2">
                                    Author
                                </Form.Label>
                                <Col sm="10">
                                    <Form.Control type="text" placeholder='Enter author last naame' onChange={(e) => setNewCourseAuthorLastName(e.target.value)} />
                                </Col>
                            </Form.Group>
                            <Form.Group as={Row} className="mb-3" controlId="formPlaintextDescription">
                                <Form.Label column sm="2">
                                    Description
                                </Form.Label>
                                <Col sm="10">
                                    <Form.Control type="text" placeholder='Enter course description' onChange={(e) => setNewCourseDescription(e.target.value)} />
                                </Col>
                            </Form.Group>
                            <Form.Group as={Row} className="mb-3" controlId="formPlaintextTopic">
                                <Form.Label column sm="2">
                                    Topic
                                </Form.Label>
                                <Col sm="10">
                                    <Form.Control type="text" placeholder='Enter course topic' onChange={(e) => setNewCourseTopic(e.target.value)} />
                                </Col>
                            </Form.Group>
                            <Form.Group as={Row} className="mb-3" controlId="formPlaintextUrl">
                                <Form.Label column sm="2">
                                    Url
                                </Form.Label>
                                <Col sm="10">
                                    <Form.Control type="text" placeholder='Enter course url' onChange={(e) => setNewCourseUrl(e.target.value)} />
                                </Col>
                            </Form.Group>
                        </Form>
                    </>
                </Modal.Body>
                <Modal.Footer>
                    <Button variant="secondary" onClick={() => setShowAddModal(false)}>
                        Close
                    </Button>
                    <Button variant="primary" onClick={() => handleSaveCourse()}>
                        Save Changes
                    </Button>
                </Modal.Footer>
            </Modal>
```

Happy testing and good luck! If you want to refer to the finished component [here is the reference](https://github.com/AlanKostrick/graphlql-demo/blob/lab-solution/client/src/screens/CoursesScreen.js)
